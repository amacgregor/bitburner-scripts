/** @param {NS} ns **/
export async function main(ns) {
    
    var server = ns.args[0];   //Host to hack
    var server2 = ns.getHostname(); //Server to run scripts on
    var i=0;
    var c=0;
    var player = ns.getPlayer();
    var fserver = ns.getServer(server);
    var contstantRam = ns.getScriptRam("/newserver/EOP.ns"); //grabbing script RAM values
    var hackscriptRam = ns.getScriptRam("/newserver/hack.ns");
    var growscriptRam = ns.getScriptRam("/newserver/grow.ns");
    var weakenscriptRam = ns.getScriptRam("/newserver/weaken.ns");
    var maxRam = (ns.getServerMaxRam(server2) - contstantRam); //getting total RAM I can use that doesnt include the OP script
    var weakenThreads = (2000-((ns.getServerMinSecurityLevel(server))/0.05));
    var maxGrowThreads = ((maxRam/growscriptRam)-(weakenscriptRam*2000));
    var cs = ns.getServerSecurityLevel(server);
    var ms = ns.getServerMinSecurityLevel(server);
    var mm = ns.getServerMaxMoney(server);
    var ma = ns.getServerMoneyAvailable(server);
    
    ns.tail();
     
     
     
    //Priming the server.  Max money and Min security must be acheived for this to work
    if ((ma < mm)==true)
    {
       ns.print(`Priming: ${server}`);
       ns.exec('/newserver/weaken.ns',server2,2000,server,0);
       ns.exec('/newserver/grow.ns',server2,maxGrowThreads,server,0);
       var WeakenTime = (weakenTime(fserver,player));
       await ns.sleep(WeakenTime+1000);
       mm = ns.getServerMaxMoney(server);
       ma = ns.getServerMoneyAvailable(server);
       player = ns.getPlayer();
       fserver = ns.getServer(server);
       cs = ns.getServerSecurityLevel(server);
       ms = ns.getServerMinSecurityLevel(server);
       
    }
     
     
    //If Max Money is true, making sure security level is at its minimum
    if((cs>ms)  ==true)
    {
       ns.print(`Weakening: ${server}`);
       ns.exec('/newserver/weaken.ns',server2,2000,server,0);
       WeakenTime = (weakenTime(fserver,player));
       await ns.sleep(WeakenTime+1000);
       cs = ns.getServerSecurityLevel(server);
       ms = ns.getServerMinSecurityLevel(server);
     
    }
     
    //Refreshing server stats now that the security level is at the minmum, and maybe our player stats have changed as priming can take a while
    player = ns.getPlayer();
    fserver = ns.getServer(server);
     
    var HPercent = (hackPercent(fserver,player)*100);
    var GPercent = (growPercent(fserver,1,player,1));
    WeakenTime = (weakenTime(fserver,player));
    var GrowTime = (growTime(fserver,player));
    var HackTime = (hackTime(fserver,player));
     
    var growThreads = Math.round(((5/(GPercent-1)))); //Getting the amount of threads I need to grow 200%.  I only need 100% but I'm being conservative here
    var hackThreads = Math.round((50/HPercent));  //Getting the amount of threads I need to hack 50% of the funds
    weakenThreads = Math.round((weakenThreads - (growThreads*0.004))); //Getting required threads to fully weaken the server
     
    var totalRamForRun = (hackscriptRam*hackThreads)+(growscriptRam*growThreads)+(weakenscriptRam*weakenThreads) //Calculating how much RAM is used for a single run
    var sleepTime = (WeakenTime/(maxRam/totalRamForRun)) //finding how many runs this server can handle and setting the time between run execution
     
    //if (sleepTime<500) // Testing forcing a min sleep time of 500 ms
    //{sleepTime = 500;
    //}
     
    var shiftCount = maxRam/totalRamForRun;
    var offset = sleepTime/2
    var gOffset = offset/4
    var hOffset = offset/2
     
     
    while(true)
     {  
         var wsleep = 0; //At one point I made the weaken call sleep so I've kept it around
         var gsleep = ((WeakenTime - GrowTime-gOffset)); //Getting the time to have the Growth execution sleep, then shaving some off to beat the weaken execution
         var hsleep = ((WeakenTime - HackTime-hOffset)); //Getting time for hack, shaving off more to make sure it beats both weaken and growth
         var UsedRam = ns.getServerUsedRam(server2);
        
     
        if((totalRamForRun>= (maxRam-UsedRam))==false) //making sure I have enough RAM to do a full run
        {
          ns.exec('/newserver/weaken.ns',server2,weakenThreads,server,wsleep,i);
          ns.exec('/newserver/grow.ns',server2,growThreads,server,gsleep,i);
          ns.exec('/newserver/hack.ns',server2,hackThreads,server,hsleep,i);
        
        if (c<shiftCount)
        {await ns.sleep(sleepTime)
        c++
        }
        else
        {
           await ns.sleep(sleepTime+offset);
           c=0;
        }
        
        
        i++
        }
        else{
           ns.print(`Not enough RAM. ${(maxRam-UsedRam)} available but ${totalRamForRun} needed`)
           await ns.sleep(1000) 
        }
     }
     await ns.sleep(120000)
}

export function hackPercent(server, player){
 
    const balanceFactor = 240;
    const difficultyMult = (100 - server.hackDifficulty) / 100;
    const skillMult = (player.hacking - (server.requiredHackingSkill - 1)) / player.hacking;
    const percentMoneyHacked = (difficultyMult * skillMult * player.hacking_money_mult) / balanceFactor;
    if (percentMoneyHacked < 0) {
      return 0;
    }
    if (percentMoneyHacked > 1) {
      return 1;
    }
    return percentMoneyHacked * 1//BitNodeMultipliers.ScriptHackMoney;
}
 
export function growPercent(server, threads, player, cores = 1) {
 
    const numServerGrowthCycles = Math.max(Math.floor(threads), 0);
    const growthRate = 1.03//CONSTANTS.ServerBaseGrowthRate;
    let adjGrowthRate = 1 + (growthRate - 1) / server.hackDifficulty;
    if (adjGrowthRate > 1.0035/*CONSTANTS.ServerMaxGrowthRate*/) {
        adjGrowthRate = 1.0035/*CONSTANTS.ServerMaxGrowthRate*/;
    }
    const serverGrowthPercentage = server.serverGrowth / 100;
    const numServerGrowthCyclesAdjusted =
        numServerGrowthCycles * serverGrowthPercentage * 1//BitNodeMultipliers.ServerGrowthRate;
    const coreBonus = 1 + (cores - 1) / 16;
    return Math.pow(adjGrowthRate, numServerGrowthCyclesAdjusted * player.hacking_grow_mult * coreBonus);
}
 
export function weakenTime(server, player) {
 
    const weakenTimeMultiplier = 4;
    return weakenTimeMultiplier * utilCalculateHackingTime(server, player) * 1000;
}
 
export function growTime(server, player) {
 
    const growTimeMultiplier = 3.2;
    return growTimeMultiplier * utilCalculateHackingTime(server, player) * 1000;
}
 
export function hackTime(server, player) {
 
    return utilCalculateHackingTime(server,player) * 1000;
}
 
function utilCalculateIntelligenceBonus(intelligence, weight = 1) {
    return 1 + (weight * Math.pow(intelligence, 0.8)) / 600;
}
 
function utilCalculateHackingTime(server, player) {
    
    const difficultyMult = server.requiredHackingSkill * server.hackDifficulty;
    const baseDiff = 500;
    const baseSkill = 50;
    const diffFactor = 2.5;
    let skillFactor = diffFactor * difficultyMult + baseDiff;
    skillFactor /= player.hacking + baseSkill;
    const hackTimeMultiplier = 5;
    const hackingTime =
        (hackTimeMultiplier * skillFactor) /
        (player.hacking_speed_mult * utilCalculateIntelligenceBonus(player.intelligence, 1));
    return hackingTime;
}